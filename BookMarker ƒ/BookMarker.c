/* Include the header file */#include "BookMarker.h"/* Calls all the other functions */void main(void){	ToolboxInit();		DoGestalt();		EventInit();		EventLoop();}/* Calls Gestalt() to make sure certain features are present */void DoGestalt(void){	OSErr	err;	long	feature;		err=Gestalt(gestaltAppleEventsAttr, &feature);	if(err!=noErr)		DoError("\pProblem calling Gestalt!", (long)err, 1);		if(!(feature & (kGestaltMask << gestaltAppleEventsPresent)))		DoError("\pAppleEvents not available!", nil, 2);			err=Gestalt(gestaltFSAttr, &feature);	if(err!=noErr)		DoError("\pProblem calling Gestalt!", (long)err, 7);			if(!(feature & (kGestaltMask << gestaltHasFSSpecCalls)))		DoError("\pFSSpec's not available!", nil, 8);			err=Gestalt(gestaltStandardFileAttr, &feature);	if(err!=noErr)		DoError("\pProblem calling Gestalt!", (long)err, 3);			if(!(feature & (kGestaltMask << gestaltStandardFile58)))		DoError("\pStandard File Package not supported!", nil, 4);}/* Installs UPP's for the Core AppleEvents */void EventInit(void){	/* Local Variables */	OSErr	err;		OAPPHandlerUPP=NewAEEventHandlerProc(DoOpenApp);	err=AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, OAPPHandlerUPP, nil, false);	if(err!=noErr)		DoError("\pProblem installing AppleEvent handler!", (long)err, 723);			ODOCHandlerUPP=NewAEEventHandlerProc(DoOpenDoc);	err=AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments, ODOCHandlerUPP, nil, false);	if(err!=noErr)		DoError("\pProblem installing AppleEvent handler!", (long)err, 724);			PDOCHandlerUPP=NewAEEventHandlerProc(DoPrintDoc);	err=AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments, PDOCHandlerUPP, nil, false);	if(err!=noErr)		DoError("\pProblem installing AppleEvent handler!", (long)err, 725);			QUITHandlerUPP=NewAEEventHandlerProc(DoQuitApp);	err=AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, QUITHandlerUPP, nil, false);	if(err!=noErr)		DoError("\pProblem installing AppleEvent handler!", (long)err, 723);}/* Calls DoConvertFolder() when the application is opened without any files */pascal OSErr DoOpenApp(AppleEvent *theAppleEvent, AppleEvent *reply, long refCon){	DoGetFolder();		return noErr;}/* Changes file's creators and/or types for each file  double-clicked or dragged onto BookMarker's icon */pascal OSErr DoOpenDoc(AppleEvent *theAppleEvent, AppleEvent *reply, long refCon){	/* Local Variables */	AEDescList	fileSpecList;	FSSpec		spec;	OSErr		err;	DescType	type;	Size		actual;	AEKeyword	keyword;	long		count, i;	err=AEGetParamDesc(theAppleEvent, keyDirectObject, typeAEList, &fileSpecList);	if(err!=noErr)		DoError("\pAppleEvent related error!", (long)err, 12);		err=GotRequiredParams(theAppleEvent);	if(err!=noErr)		DoError("\pAppleEvent related error!", (long)err, 13);			err=AECountItems(&fileSpecList, &count);	if(err!=noErr)		DoError("\pAppleEvent related error!", (long)err, 14);		for(i=1; i<=count; i++)	{		err=AEGetNthPtr(&fileSpecList, i, typeFSS, &keyword, &type, (Ptr)&spec, sizeof(FSSpec), &actual);		if(err!=noErr)			DoError("\pAppleEvent related problem!", (long)err, 15);					DoChangeCreator(spec);	}		Quit(false);	return noErr;}	/* Changes the modification a file's parent folder so it displays the new icon */void DoTouch(FSSpec spec){	/* Local Variables */	CInfoPBRec	myCPB;	if(spec.parID!=1)	{		myCPB.dirInfo.ioDrDirID=spec.parID;		myCPB.dirInfo.ioVRefNum=spec.vRefNum;		myCPB.dirInfo.ioNamePtr=nil;		myCPB.dirInfo.ioFDirIndex=-1;				if(PBGetCatInfoSync(&myCPB)==noErr)		{			GetDateTime(&(myCPB.dirInfo.ioDrMdDat));			PBSetCatInfoSync(&myCPB);		}		else			DoError("\pProblem setting folder date!", 0L, 20);	}}/* Presents the StandardGetFile dialog to select a file, and then changes the creator of all files in that folder */void DoGetFolder(void){	FSSpec				spec[kMaxNumFSSpecs];	OSErr				err;	short				theFlags, itemCount, i, itemIndex=1;	StandardFolderReply	reply;		theFlags=kSGFDefaultFlags+kSGFHideNewFolderButton;	err=StandardGetFolder("\pChoose a folder:", &reply, theFlags, NULL);		if(err!=noErr)		DoError("\pProblem choosing folder!", 0L, 1917);		if(reply.sfGood)	{		do		{    		err=GetDirItems(reply.sfVRefNum, reply.sfDirID, NULL, true, true, spec, kMaxNumFSSpecs, &itemCount, &itemIndex);			for (i=0; i<itemCount; ++i)				DoChangeCreator(spec[i]);		}		while(err==noErr);	}		Quit(false);	}/* Changes creator of the file referred to by spec */void DoChangeCreator(FSSpec spec){	OSErr	err;	FInfo	finderInfo, newInfo;		err=FSpGetFInfo(&spec, &finderInfo);	if((err!=noErr)&&(!(IsFolder(spec))))		DoError("\pFinder info related error!", (long)err, 17);		newInfo=finderInfo;	switch(newInfo.fdType)	{		case kTextType:			switch(finderInfo.fdCreator)			{				case kCreator:					newInfo.fdCreator=kDefaultTextCreator;				break;							default:					newInfo.fdCreator=kCreator;				break;			}		break;				case kURLType:			if(finderInfo.fdCreator==kCreator)				newInfo.fdCreator=kDefaultTextCreator;			else				newInfo.fdCreator=kCreator;			newInfo.fdType=kTextType;		break;				case kClipType:			newInfo.fdCreator=kCreator;			newInfo.fdType=kNewClipType;		break;			case kNewClipType:			newInfo.fdCreator=kDefaultClipCreator;			newInfo.fdType=kClipType;		break;	}					err=FSpSetFInfo(&spec, &newInfo);	if((err!=noErr)&&(!(IsFolder(spec))))		DoError("\pFinder info related error!", (long)err, 18);				DoTouch(spec);}/* Presents a message saying printing is not supported */pascal OSErr DoPrintDoc(AppleEvent *theAppleEvent, AppleEvent *reply, long refCon){	DoError("\pPrinting is not supported!", nil, 19);		return noErr;}/* Responds to the Quit AppleEvent by excetuting the Quit() function with the parameter of false */pascal OSErr DoQuitApp(AppleEvent *theAppleEvent, AppleEvent *reply, long refCon){	Quit(false);		return noErr;}/* Main event loop */void EventLoop(void){	/* Local Variables */	EventRecord event;	Point		diskLoc;		while(gDone==false)	{		WaitNextEvent(everyEvent, &event, kSleep, nil);				switch(event.what)		{			case kHighLevelEvent:				AEProcessAppleEvent(&event);			break;						case diskEvt:				if(HiWord(event.message)!=noErr)				{					diskLoc.h=diskLoc.v=50;					DILoad();					DIBadMount(diskLoc, event.message);					DIUnload();				}			break;		}	}}