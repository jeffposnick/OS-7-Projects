/* #Includes */#include "URL Clerk.h"/* Calls all the other functions */void main(void){	ToolboxInit();		DoGestalt();		EventInit();		DoPreferences();		MakeMenus();		ICInit();		EventLoop();}/* Handles intitialization of preferences */void DoPreferences(void){	OSErr	err;	FSSpec	spec;	Handle	tempHandle;	short	resNum, vRefNum, resErr;	long	dirID;	gAppResNum=CurResFile();	tempHandle=Get1Resource(kPrefsType, kPrefsID);	if(tempHandle==nil)		DoError("\pProblem reading resources!", nil, 999);	BlockMoveData(*tempHandle, &gDefaultPrefs, sizeof(Preferences));	err=FindFolder(kOnSystemDisk, kPreferencesFolderType, kDontCreateFolder, &vRefNum, &dirID);	err=FSMakeFSSpec(vRefNum, dirID, kPrefsFileName, &spec);	resNum=FSpOpenResFile(&spec, fsRdWrPerm);	if(resNum==-1)		resNum=DoCreatePrefs();		if(resNum==-1)		DoError("\pProblem opening preferences files!", (long)resNum, 98);	UseResFile(resNum);		tempHandle=Get1Resource(kPrefsType, kPrefsID);	if(tempHandle==nil)	{		CloseResFile(resNum);		DoError("\pProblem reading prefernces!", nil, 67);	}		BlockMoveData(*tempHandle, &gPreferences, sizeof(Preferences));		ReleaseResource(tempHandle);	if((resErr=ResError())!=noErr)		DoError("\pCan't release resource!", (long)resErr, 6754);		gPrefsResNum=resNum;}/* Installs UPP's for the Core AppleEvents */void EventInit(void){	OSErr	err;		OAPPHandlerUPP=NewAEEventHandlerProc(DoOpenApp);	err=AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, OAPPHandlerUPP, nil, false);	if(err!=noErr)		DoError("\pProblem installing AppleEvent handler!", (long)err, 723);			ODOCHandlerUPP=NewAEEventHandlerProc(DoOpenDoc);	err=AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments, ODOCHandlerUPP, nil, false);	if(err!=noErr)		DoError("\pProblem installing AppleEvent handler!", (long)err, 724);			PDOCHandlerUPP=NewAEEventHandlerProc(DoPrintDoc);	err=AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments, PDOCHandlerUPP, nil, false);	if(err!=noErr)		DoError("\pProblem installing AppleEvent handler!", (long)err, 725);			QUITHandlerUPP=NewAEEventHandlerProc(DoQuitApp);	err=AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, QUITHandlerUPP, nil, false);	if(err!=noErr)		DoError("\pProblem installing AppleEvent handler!", (long)err, 726);}/* Calls Gestalt() to make sure certain features are present */void DoGestalt(void){	OSErr	err;	long	feature;		err=Gestalt(gestaltAppleEventsAttr, &feature);	if(err!=noErr)		DoError("\pProblem calling Gestalt!", (long)err, 21);		if(!(feature & (kGestaltMask << gestaltAppleEventsPresent)))		DoError("\pAppleEvents not available! Your system software may be too old.", nil, 22);			err=Gestalt(gestaltFSAttr, &feature);	if(err!=noErr)		DoError("\pProblem calling Gestalt!", (long)err, 27);			if(!(feature & (kGestaltMask << gestaltHasFSSpecCalls)))		DoError("\pFSSpec's not available! Your system software may be too old.", nil, 28);			err=Gestalt(gestaltPopupAttr, &feature);	if(err!=noErr)		DoError("\pProblem calling Gestalt!", (long)err, 31);			if(!(feature & (kGestaltMask << gestaltPopupPresent)))		DoError("\pPopup menus not supported! Your system software may be too old.", nil, 32);			err=Gestalt(gestaltStandardFileAttr, &feature);	if(err!=noErr)		DoError("\pProblem calling Gestalt!", (long)err, 33);			if(!(feature & (kGestaltMask << gestaltStandardFile58)))		DoError("\pStandard File Package not supported! Your system software may be too old.", nil, 34);			err=Gestalt(gestaltFindFolderAttr, &feature);	if(err!=noErr)		DoError("\pProblem calling Gestalt!", (long)err, 35);			if(!(feature & (kGestaltMask << gestaltFindFolderPresent)))		DoError("\pFind Folder not supported! Your system software may be too old.", nil, 36);}/* Draws the menu bar */void MakeMenus(void){	Handle 		menuBar;	MenuHandle 	menuHandle;		menuBar=GetNewMBar(kMenuBarID);	SetMenuBar(menuBar);	DisposeHandle(menuBar);		menuHandle=GetMHandle(mApple);	AppendResMenu(menuHandle, kAppleMenuItems);	DrawMenuBar();	menuHandle=GetMHandle(mEdit);	if(gPreferences.quitOnClose==kQuit)		SetItemMark(menuHandle, iToggleQuit, checkMark);	else		SetItemMark(menuHandle, iToggleQuit, noMark);			if(gPreferences.autoConvert==kConvert)		SetItemMark(menuHandle, iAutoConvert, checkMark);	else		SetItemMark(menuHandle, iAutoConvert, noMark);}/* Does nothing */pascal OSErr DoOpenApp(AppleEvent *theAppleEvent, AppleEvent *reply, long refCon){	return noErr;}/* Opens documents and calls the appropriate procedure to launch their URL */pascal OSErr DoOpenDoc(AppleEvent *theAppleEvent, AppleEvent *reply, long refCon){	AEDescList	fileSpecList;	FSSpec		spec;	OSErr		err;	DescType	type;	Size		actual;	AEKeyword	keyword;	FInfo		finderInfo;	long		count, i;		err=AEGetParamDesc(theAppleEvent, keyDirectObject, typeAEList, &fileSpecList);	if(err!=noErr)		DoError("\pAppleEvent related error!", (long)err, 2);		err=GotRequiredParams(theAppleEvent);	if(err!=noErr)		DoError("\pAppleEvent related error!", (long)err, 3);			err=AECountItems(&fileSpecList, &count);	if(err!=noErr)		DoError("\pAppleEvent related error!", (long)err, 4);		for(i=1; i<=count; i++)	{		err=AEGetNthPtr(&fileSpecList, i, typeFSS, &keyword, &type, (Ptr)&spec, sizeof(FSSpec), &actual);		if(err!=noErr)			DoError("\pAppleEvent related error!", (long)err, 5);			err=FSpGetFInfo(&spec, &finderInfo);		if(err!=noErr)			DoError("\pFinder info related error!", (long)err, 6);				switch(finderInfo.fdType)		{			case kTextType:			case kURLType:			case kClipType:			case kNewClipType:				DoLaunchURLInFile(spec);			break;						default:				DoError("\pThis is not a valid bookmark file!", nil, 7);			break;		}	}		return noErr;}/* Presents a message saying printing is not supported */pascal OSErr DoPrintDoc(AppleEvent *theAppleEvent, AppleEvent *reply, long refCon){	DoError("\pPrinting is not supported!", nil, 8);		return errAEEventNotHandled;}/* Responds to the Quit AppleEvent by excetuting the DoQuit() function */pascal OSErr DoQuitApp(AppleEvent *theAppleEvent, AppleEvent *reply, long refCon){	DoQuit();		return noErr;}/* Creates a resource file with defualt values if one is not present */short DoCreatePrefs(void){	OSErr	err;	FSSpec	spec;	short	resNum, resErr, vRefNum;	long	dirID;	err=FindFolder(kOnSystemDisk, kPreferencesFolderType, kDontCreateFolder, &vRefNum, &dirID);	err=FSMakeFSSpec(vRefNum, dirID, kPrefsFileName, &spec);		FSpCreateResFile(&spec, kCreator, kPrefsFileType, smSystemScript);	if((resErr=ResError())!=noErr)		DoError("\pProblem creating preferences file! Is there another copy of URL Clerk running?", (long)resErr, 74);			resNum=FSpOpenResFile(&spec, fsRdWrPerm);	if(resNum==-1)		return resNum;	DoCopyResource(resNum);		return resNum;}/* Reads in a URL from the file theSpec and reutrns it as a Ptr */Ptr GetURLAsPtr(FSSpec theSpec){	FInfo	theInfo;	Str255	comment="\p";	OSErr	err;	Ptr		buffer;	Handle	theTextHandle;	long	length;	short	refNum, resNum, resErr;		err=FSpDTGetComment(&theSpec, comment);	if((err!=noErr)&&(err!=-5012))		DoError("\pPreblem getting file's comment!", (long)err, 22222);			if(comment[0])	{		ChangeToColon(comment);		return Str255ToPtr(comment);	}		err=FSpGetFInfo(&theSpec, &theInfo);	if((err!=noErr)&&(err!=fnfErr))		DoError("\pProblem getting info for a file!", (long)err, 24532);				switch(theInfo.fdType)	{		case kTextType:		case kURLType:		case kAnarchieType:		case kAnarchieURLType:			err=FSpOpenDF(&theSpec, fsRdPerm, &refNum);			if(err!=noErr)				DoError("\pProblem opening file's data fork!", (long)err, 4555);					err=SetFPos(refNum, fsFromStart, 0);			if(err!=noErr)				DoError("\pProblem reading file's data fork!", (long)err, 4556);					err=GetEOF(refNum, &length);			if(err!=noErr)				DoError("\pProblem reading file's data fork!", (long)err, 4557);					buffer=NewPtrClear(length);			if(buffer==nil)				DoError("\pOut of memory!", nil, 12);					err=FSRead(refNum, &length, buffer);			if(err!=noErr)				DoError("\pProblem reading file's data fork!", (long)err, 4558);			err=FSClose(refNum);			if(err!=noErr)				DoError("\pProblem closing file's data fork!", (long)err, 4599);						err=FlushVol(kEmptyString, theSpec.vRefNum);			if(err!=noErr)				DoError("\pProblem flushing volume!", (long)err, 6738);		break;					case kClipType:		case kNewClipType:			resNum=FSpOpenResFile(&theSpec, fsRdPerm);			if((resErr=ResError())!=noErr)			{				CloseResFile(resNum);				DoError("\pResource-realted error!", (long)resErr, 4700);			}			theTextHandle=Get1IndResource(kTextType, 1);			if((resErr=ResError())!=noErr)			{				CloseResFile(resNum);				DoError("\pResource-realted error!", (long)resErr, 4701);			}				HLock(theTextHandle);			buffer=NewPtrClear(GetHandleSize(theTextHandle));			CopyPtr(*theTextHandle, buffer);			HUnlock(theTextHandle);			ReleaseResource(theTextHandle);							CloseResFile(resNum);		break;					default:			DoError("\pThis is not a valid bookmark file!", nil, 84533);		break;	}		if(theInfo.fdCreator!=kNetscapeCreator)	{		PtrToStr255(GetPtrSize(buffer), buffer, comment);		ChangeFromColon(comment);		err=FSpDTSetComment(&theSpec, comment);		if((err!=noErr)&&(err!=-44))			DoError("\pPreblem setting file's comment!", (long)err, 22223);	}		return buffer;}/* Reads in a URL from the file theSpec and reutrns it as a Str255 */void GetURLAsStr255(FSSpec theSpec, Str255 *theURL){	Ptr		buffer;		buffer=GetURLAsPtr(theSpec);	PtrToStr255(GetPtrSize(buffer), buffer, *theURL);	DisposePtr(buffer);}/* Copies defualt preferences from application to prefs file */void DoCopyResource(short dest){	Handle	prefs;	OSErr	err;	short	resErr, curResFile;		curResFile=CurResFile();	UseResFile(dest);	if((resErr=ResError())!=noErr)		DoError("\pProblem with file's resources!", (long)resErr, 124);		err=PtrToHand(&gDefaultPrefs, &prefs, sizeof(Preferences));	if(err!=noErr)		DoError("\pOut of memory!", (long)err, 125);			AddResource(prefs, kPrefsType, kPrefsID, kEmptyString);	if((resErr=ResError())!=noErr)		DoError("\pProblem adding resources!", (long)resErr, 126);			WriteResource(prefs);	if((resErr=ResError())!=noErr)		DoError("\pProblem with file's resources!", (long)resErr, 129);		ReleaseResource(prefs);	if((resErr=ResError())!=noErr)	{		CloseResFile(dest);		DoError("\pResource-realted error!", (long)resErr, 1608);	}		UseResFile(curResFile);}/* Launches the URL in the file spec */void DoLaunchURLInFile(FSSpec spec){	Ptr		theURL;	ICError	icErr;	long	start=0, length;		theURL=GetURLAsPtr(spec);		length=GetPtrSize(theURL);		icErr=ICLaunchURL(gInst, kEmptyString, theURL, length, &start, &length);	if(icErr!=noErr)		DoError("\pProblem launching URL! Check to make sure the URL is valid and that Internet Config is set up correctly.", (long)icErr, 14);			DisposePtr(theURL);		if(gPreferences.autoConvert==kConvert)		DoChangeCreator(spec);		if(gPreferences.quitOnClose==kQuit)		DoQuit();}/* Changes creator of the file referred to by spec */void DoChangeCreator(FSSpec spec){	OSErr	err;	FInfo	finderInfo, newInfo;		err=FSpGetFInfo(&spec, &finderInfo);	if(err!=noErr)		DoError("\pFinder info related error!", (long)err, 678);		newInfo=finderInfo;	newInfo.fdCreator=kCreator;	switch(newInfo.fdType)	{		case kClipType:			newInfo.fdType=kNewClipType;		break;			case kURLType:			newInfo.fdType=kTextType;		break;	}			err=FSpSetFInfo(&spec, &newInfo);	if(err!=noErr)		DoError("\pCan't change file's creator. The file might be on a read-only disk.", (long)err, 679);			DoTouch(spec);}/* Changes the modification a file's parent folder so it displays the new icon */void DoTouch(FSSpec spec){	CInfoPBRec	myCPB;	if(spec.parID!=1)	{		myCPB.dirInfo.ioDrDirID=spec.parID;		myCPB.dirInfo.ioVRefNum=spec.vRefNum;		myCPB.dirInfo.ioNamePtr=nil;		myCPB.dirInfo.ioFDirIndex=-1;				if(PBGetCatInfoSync(&myCPB)==noErr)		{			GetDateTime(&(myCPB.dirInfo.ioDrMdDat));			PBSetCatInfoSync(&myCPB);		}		else			DoError("\pProblem setting folder date!", nil, 20);	}}/* Returns the type of URL stored in the theSpec */short GetURLType(FSSpec theSpec){	Str255	theURL;	OSErr	err;	FInfo	theInfo;	char	ch;		err=FSpGetFInfo(&theSpec, &theInfo);	if(err!=fnfErr)		GetURLAsStr255(theSpec, &theURL);	else		return pNone;			if(theURL[1]=='<')		ch=theURL[2];	else		ch=theURL[1];		switch(ch)	{		case 'h':			return pHttp;		break;				case 'f':			return pFtp;		break;				case 'm':			return pMail;		break;				case 't':			return pTelnet;		break;				case 'n':			return pNews;		break;				case 'g':			return pGopher;		break;				default:			return pNone;		break;	}}/* Initializes Internet Config and quits if it is not present */void ICInit(void){	ICError	icErr;		icErr=ICStart(&gInst, kCreator);	if(icErr!=noErr)	{		ParamText("\pProblem intializing Internet Config. Please make sure you are using at least version 1.1 and try again!", "\p0", "\p21", "\p");			StopAlert(kFatalAlertID, nil);				ExitToShell();	}		icErr=ICFindConfigFile(gInst, 0, nil);	if(icErr!=noErr)		DoError("\pProblem locating Internet Config preferences file!", (long)icErr, 18);}/* Main event loop */void EventLoop(void){	EventRecord event;	WindowPtr	tempWindow;	OSErr		err;	FInfo		finderInfo;	FSSpec		spec;	Point		diskLoc;	char 		theChar;	short 		thePart;		while(!gDone)	{		WaitNextEvent(everyEvent, &event, kSleep, nil);				switch(event.what)		{			case keyDown:			case autoKey:				theChar=(event.message & charCodeMask);				if((event.modifiers&cmdKey)!=0) 					HandleMenuChoice(MenuKey(theChar));			break;						case kHighLevelEvent:				AEProcessAppleEvent(&event);			break;						case osEvt:				HiliteMenu(0);			break;						case nullEvent:				if((gPreferences.vRefNum!=kJunk)&&(gPreferences.dirID!=kJunk))				{					if(CheckTime())					{						if(gFlag)						{							gFlag=false;														err=FSMakeFSSpec(gPreferences.vRefNum, gPreferences.dirID, gPreferences.name, &spec);							if(err!=noErr)								DoError("\pProblem making FSSpec!", (long)err, 197);															err=FSpGetFInfo(&spec, &finderInfo);							if(err!=noErr)								DoError("\pFinder info related error!", (long)err, 19);							switch(finderInfo.fdType)							{								case kTextType:								case kURLType:								case kClipType:								case kNewClipType:									DoLaunchURLInFile(spec);								break;																default:									DoError("\pThis is not a valid bookmark file!", nil, 20);								break;							}						}					}					else						gFlag=true;				}			break;						case mouseDown:				thePart=FindWindow(event.where, &tempWindow);				switch(thePart)				{					case inMenuBar:						HandleMenuChoice(MenuSelect(event.where));					break;										case inSysWindow:						SystemClick(&event, tempWindow);					break;				}			break;						case diskEvt:				if(HiWord(event.message)!=noErr)				{					diskLoc.h=diskLoc.v=50;					DILoad();					DIBadMount(diskLoc, event.message);					DIUnload();				}			break;		}	}}/* Handles user interaction in menus */void HandleMenuChoice(long menuChoice){	MenuHandle 		appleMenu, editHandle;	Str255 			accName;	short 			menu, menuItem;		if(menuChoice>0)	{		menu=HiWord(menuChoice);		menuItem=LoWord(menuChoice);				switch(menu)		{			case mApple:				switch(menuItem)				{					case iAbout:						Alert(kAboutBoxID, nil);					break;										default:						appleMenu=GetMHandle(mApple);						GetItem(appleMenu, menuItem, accName );						OpenDeskAcc(accName);					break;				}			break;						case mFile:				switch(menuItem)				{					case iNew:						DoCreateURL();					break;										case iOpen:						DoOpenURL();					break;										case iExtractURL:						DoExtractURL();					break;										case iExportURL:						DoExportURL();					break;										case iEdit:						DoEditURL();					break;										case iFind:						DoFind();					break;										case iFindWebSite:						DoSearchOnWeb();					break;									case iSchedule:						DoSchedule();					break;										case iQuit:						DoQuit();					break;				}			break;						case mEdit:				editHandle=GetMHandle(mEdit);								switch(menuItem)				{					case iPaste:						if(gDialogPresent)							DialogPaste(gDialog);					break;										case iToggleQuit:						if(gPreferences.quitOnClose==kDontQuit)						{							gPreferences.quitOnClose=kQuit;							SetItemMark(editHandle, iToggleQuit, checkMark);						}						else						{							gPreferences.quitOnClose=kDontQuit;							SetItemMark(editHandle, iToggleQuit, noMark);						}											break;									case iAutoConvert:						if(gPreferences.autoConvert==kDontConvert)						{							gPreferences.autoConvert=kConvert;							SetItemMark(editHandle, iAutoConvert, checkMark);						}						else						{							gPreferences.autoConvert=kDontConvert;							SetItemMark(editHandle, iAutoConvert, noMark);						}											break;				}		}				HiliteMenu(0);	}}/* Checks the day against a global value */Boolean CheckTime(void){	DateTimeRec		timeRec;	unsigned long	secs;		GetDateTime(&secs);	SecondsToDate(secs, &timeRec);		switch(gPreferences.day)	{		case pSunday:		case pMonday:		case pTuesday:		case pWednesday:		case pThursday:		case pFriday:		case pSaturday:			if(gPreferences.day==timeRec.dayOfWeek)			{				if(CheckHour(timeRec.hour))				{					if(CheckMinute(timeRec.minute))						return true;				}			}		break;				case pWeekday:			if((timeRec.dayOfWeek>=2)&&(timeRec.dayOfWeek<=6))			{				if(CheckHour(timeRec.hour))				{					if(CheckMinute(timeRec.minute))						return true;				}			}		break;				case pWeekend:			if((timeRec.dayOfWeek==1)||(timeRec.dayOfWeek==7))			{				if(CheckHour(timeRec.hour))				{					if(CheckMinute(timeRec.minute))						return true;				}			}		break;				case pEveryDay:			if(CheckHour(timeRec.hour))			{				if(CheckMinute(timeRec.minute))					return true;			}		break;	}		return false;}/* Checks the current hour against a global value */Boolean CheckHour(int hour){	int	curHour=gPreferences.hour;		if((gPreferences.amPm==2)&&(!(curHour==pEveryHour)))		curHour+=12;		if((curHour==hour)||((gPreferences.amPm==3)&&((curHour+12)==hour))||(curHour==pEveryHour))		return true;	else		return false;}/* Checks the current minute against a global value */Boolean CheckMinute(int minute){	if(gPreferences.minute==pEvery5Minutes)		return (minute%5==0);	else		return (minute==(((gPreferences.minute)-1)*5));}/* Displays a dialog promtping the user to enter a URL, then saves it as a bookmark file or launches it */void DoCreateURL(void){	Boolean				done=false;	StandardFileReply	reply;	FSSpec				spec;	Handle				editTextHandle, theURLHandle;	Rect				rect;	Str255				theURL;	StringHandle		theString;	OSErr				err;	ICError				icErr;	long				start=nil, end;	short				itemHit, resErr, type;		gDialogPresent=true;	gDialog=GetNewDialog(kCreateURLDialogID, nil, kMoveToFront);	if(gDialog==nil)		DoError("\pWhat's wrong with the dialog resource?", 0L, 4334);		theString=GetString(kStringID);	if((resErr=ResError())!=noErr)		DoError("\pProblem reading string!", (long)resErr, 1829);		GetDialogItem(gDialog, dURL, &type, &editTextHandle, &rect);	HLock((Handle)theString);	SetDialogItemText(editTextHandle, *theString);	HUnlock((Handle)theString);	ReleaseResource((Handle)theString);	SetDialogDefaultItem(gDialog, dLaunch);	SetDialogCancelItem(gDialog, dDone);	SetDialogTracksCursor(gDialog, true);	SelectDialogItemText(gDialog, dURL, 0L, 32767L);		ShowWindow(gDialog);	SetPort(gDialog);		while(!done)	{		ModalDialog(nil, &itemHit);				switch(itemHit)		{			case dSave:				StandardPutFile(kPrompt, kDefaultFileName, &reply);								if(reply.sfGood)				{					spec=reply.sfFile;					if(reply.sfReplacing)					{						err=FSpDelete(&spec);						if(err!=noErr)							DoError("\pProblem deleting old URL file!", (long)err, 872);					}										GetDialogItemText(editTextHandle, theURL);					theURLHandle=NewHandleClear(theURL[0]);					BlockMoveData(&(theURL[1]), *theURLHandle, theURL[0]);					PutURL(spec, theURLHandle);					DisposeHandle(theURLHandle);					DoTouch(spec);				}			break;						case dDone:				done=true;			break;						case dLaunch:				GetDialogItemText(editTextHandle, theURL);				theURLHandle=NewHandleClear(theURL[0]);				BlockMoveData(&(theURL[1]), *theURLHandle, theURL[0]);								HLock(theURLHandle);				end=GetHandleSize(theURLHandle);				icErr=ICLaunchURL(gInst, kEmptyString, *theURLHandle, end, &start, &end);				HUnlock(theURLHandle);				DisposeHandle(theURLHandle);								if(icErr!=noErr)					DoError("\pProblem launching URL! Check to make sure the URL is valid and that Internet Config is set up correctly.", (long)icErr, 579);								done=true;			break;		}	}		gDialogPresent=false;	DisposeHandle(editTextHandle);	DisposeDialog(gDialog);}/* Saves a URL into a file */void PutURL(FSSpec theLocation, Handle theURLHandle){	Str255	comment;	OSErr	err;		err=FSpCreate(&theLocation, kCreator, kTextType, smSystemScript);	if(err!=noErr)		if(err==-48)			return;		else			DoError("\pProblem creating file!", (long)err, 7612);			HLock(theURLHandle);		PtrToStr255(GetHandleSize(theURLHandle), *theURLHandle, comment);	ChangeFromColon(comment);		err=FSpDTSetComment(&theLocation, comment);		WriteToFile(theLocation, *theURLHandle);			HUnlock(theURLHandle);}/* Puts the URL in the data fork */void WriteToFile(FSSpec theFile, Ptr theURL){	OSErr	err;	long	count;	short	refNum;		err=FSpOpenDF(&theFile, fsCurPerm, &refNum);	if(err!=noErr)		DoError("\pProblem opening file!", (long)err, 6732);			err=SetFPos(refNum, fsFromStart, 0L);	if(err!=noErr)		DoError("\pProblem setting file position!", (long)err, 6733);			count=GetPtrSize(theURL);	err=FSWrite(refNum, &count, theURL);	if(err!=noErr)		DoError("\pProblem writing to file!", (long)err, 6734);			err=SetEOF(refNum, count);	if(err!=noErr)		DoError("\pProblem setting file size!", (long)err, 6735);			err=FSClose(refNum);	if(err!=noErr)		DoError("\pProblem closing file!", (long)err, 6736);			err=FlushVol(kEmptyString, theFile.vRefNum);	if(err!=noErr)		DoError("\pProblem flushing volume!", (long)err, 6737);}/* Launches a URL stored in a file */void DoOpenURL(void){	StandardFileReply	theReply;	FSSpec				spec;	FInfo				finderInfo;	OSErr				err;		ChooseFile(&theReply);	if(theReply.sfGood)	{		spec=theReply.sfFile;		err=FSpGetFInfo(&spec, &finderInfo);		if(err!=noErr)			DoError("\pFinder info related error!", (long)err, 1486);				switch(finderInfo.fdType)		{			case kTextType:			case kURLType:			case kClipType:			case kNewClipType:				DoLaunchURLInFile(spec);			break;						default:				DoError("\pThis is not a valid bookmark file!", nil, 1487);			break;		}	}}/* Extracts the URLs in a file */void DoExtractURL(void){	StandardFileReply	fileReply;	StandardFolderReply	folderReply;	OSErr				err;	Ptr					theText;	Handle				tempHandle, mailHandle;	Str63				name;	Str255				theURL;	FSSpec				spec;	Boolean				flag=false;	FInfo				finderInfo;	long				length;	short				i=0, j;		ChooseFileExtended(&fileReply);	if(fileReply.sfGood)	{		err=StandardGetFolder("\pChoose a folder to save the URLs in:", &folderReply, kSGFDefaultFlags, NULL);		if(err!=noErr)			DoError("\pProblem with StandardGetFolder!", (long)err, 1743);					if(folderReply.sfGood)		{			theText=GetURLAsPtr(fileReply.sfFile);			length=GetPtrSize(theText);						err=FSpGetFInfo(&fileReply.sfFile, &finderInfo);			if(err!=noErr)				DoError("\pFinder info related error!", (long)err, 1921);						switch(finderInfo.fdCreator)			{				case kNetscapeCreator:					while(i<length-9)					{						j=0;						if((theText[i]=='<')&&((theText[i+1]=='A')||(theText[i+1]=='a'))&&(theText[i+2]==' ')&&((theText[i+3]=='H')||(theText[i+3]=='h'))&&((theText[i+4]=='R')||(theText[i+4]=='r')))						{							flag=true;													i=i+9;							j=i;							while(theText[j]!='"')								j++;														tempHandle=NewHandleClear(j-i);							BlockMoveData(&(theText[i]), *tempHandle, j-i);													while(theText[i]!='>')								i++;							j=i;													while(theText[j]!='<')								j++;														if(j-i>31)								name[0]=31;							else									name[0]=j-i-1;													BlockMoveData(&(theText[i+1]), &(name[1]), name[0]);													ChangeColon(name);													err=FSMakeFSSpec(folderReply.sfVRefNum, folderReply.sfDirID, name, &spec);							if((err!=noErr)&&(err!=fnfErr))								DoError("\pProblem making FSSpec!", (long)err, 1981);														PutURL(spec, tempHandle);							DisposeHandle(tempHandle);													i=j+2;						}						else							i++;					}				break;								case kAnarchieCreator:					while(i<length)					{						j=0;												while(theText[i]!=':')						{							name[j+1]=theText[i];							j++;							i++;						}												if(j>31)							name[0]=31;						else							name[0]=j;													i+=5;						j=0;												while((theText[i]!=13)&&(theText[i]!=0))						{							theURL[j+1]=theText[i];							j++;							i++;						}												theURL[0]=j;						i++;												err=FSMakeFSSpec(folderReply.sfVRefNum, folderReply.sfDirID, name, &spec);						if((err!=noErr)&&(err!=fnfErr))							DoError("\pProblem making FSSpec!", (long)err, 1987);												tempHandle=NewHandleClear(theURL[0]);						BlockMoveData(&(theURL[1]), *tempHandle, theURL[0]);						PutURL(spec, tempHandle);						DisposeHandle(tempHandle);					}					break;							default:					while(i<length)					{						j=0;						if(theText[i]=='<')						{							flag=true;							i++;							tempHandle=NewHandleClear(length);							if(tempHandle==nil)								DoError("\pOut of memory!", 0L, 4185);							do							{								(*tempHandle)[j]=theText[i];								j++;								i++;							}							while((theText[i]!='>')&&(i<length));												SetHandleSize(tempHandle, j);							mailHandle=HandleEMail(tempHandle);												if(mailHandle!=nil)								GetName(mailHandle, name);							else								GetName(tempHandle, name);													ChangeColon(name);												err=FSMakeFSSpec(folderReply.sfVRefNum, folderReply.sfDirID, name, &spec);							if((err!=noErr)&&(err!=fnfErr))								DoError("\pProblem making FSSpec!", (long)err, 1980);												if(mailHandle!=nil)							{								PutURL(spec, mailHandle);								DisposeHandle(mailHandle);							}							else								PutURL(spec, tempHandle);												DisposeHandle(tempHandle);						}						else							i++;					}				break;			}		}	}		if(flag)		DoTouch(spec);}/* Removes the colon from the file name and replaces it with another character */void ChangeColon(Str63 fileName){	Str63	temp;	short	i;		temp[0]=fileName[0];	for(i=1; i<=fileName[0]; i++)		if(fileName[i]==':')			temp[i]=kNewChar;		else			temp[i]=fileName[i];		CopyPString(temp, fileName);}/* Creates a name for the file for the URL */void GetName(Handle theURL, Str63 name){	Str255	temp;	short	i;	long	size;		HLock(theURL);		size=GetHandleSize(theURL);	if(size<31)		PtrToStr255(size, *theURL, name);	else	{		i=size-30;		name[0]=31;		PtrToStr255(size, *theURL, temp);		BlockMoveData(&(temp[i]), &(name[1]), 31);	}		HUnlock(theURL);}	/* Checks to see if a URL is an e-mail address and fixes it if it is */Handle HandleEMail(Handle theURL){	Handle	tempHandle;	Boolean	isEmail=false;	Str255	tempString="\pmailto:";	OSErr	err;	short	i;	long	size;		HLock(theURL);	size=GetHandleSize(theURL);	for(i=0; ((i<size)&&(!isEmail)); i++)		isEmail=((*theURL)[i]=='@');			if(isEmail)	{		for(i=0; ((i<=7)&&(isEmail)); i++)			isEmail=((*theURL)[0]==tempString[i+1]);				if(!isEmail)		{			tempHandle=NewHandleClear(7);			(*tempHandle)[0]='m';			(*tempHandle)[1]='a';			(*tempHandle)[2]='i';			(*tempHandle)[3]='l';			(*tempHandle)[4]='t';			(*tempHandle)[5]='o';			(*tempHandle)[6]=':';			HLock(tempHandle);			err=HandAndHand(theURL, tempHandle);			HUnlock(tempHandle);			if(err!=noErr)				DoError("\pError with Handles!", (long)err, 5757);			HUnlock(theURL);			return tempHandle;		}	}		HUnlock(theURL);	return nil;}/* Exports URLs to a text file enclosed in <> and seperated by a character (return by default) */void DoExportURL(void){	StandardFolderReply	folderReply;	StandardFileReply	fileReply;	DialogPtr			dialog;	OSErr				err;	FSSpec				spec;	Str63				folderName;	Str255				message;	Handle				itemHandle, exportHandle;	Rect				itemRect;	Boolean				tempBool, gotFolder=false, gotFile=false, flag=true, includeName, done=false;	short				temp, itemHit, theFlags, itemType, refNum;	long				count=0, length;	char				delim;		dialog=GetNewDialog(kExportDialogID, nil, kMoveToFront);	if(dialog==nil)		DoError("\pWhat's wrong with the dialog resource?", 0L, 8671);		SetDialogCancelItem(dialog, dCancel);	GetDialogItem(dialog, dExport, &itemType, &exportHandle, &itemRect);	HiliteControl((ControlHandle)exportHandle, kDisableButton);		ShowWindow(dialog);	SetPort(dialog);		while(!done)	{		ModalDialog(nil, &itemHit);				switch(itemHit)		{			case dCancel:				done=true;			break;						case dSourceFolder:				theFlags=kSGFDefaultFlags+kSGFHideNewFolderButton;				err=StandardGetFolder("\pCHoose the folder containing the bookmarks to export:", &folderReply, theFlags, NULL);					if(err!=noErr)					DoError("\pProblem with StandardGetFolder!", (long)err, 1729);						if(folderReply.sfGood)				{					err=GetDirName(folderReply.sfVRefNum, folderReply.sfDirID, folderName);										GetDialogItem(dialog, dSourceFolder, &itemType, &itemHandle, &itemRect);					SetIText(itemHandle, folderName);					DisposeHandle(itemHandle);										gotFolder=true;				}			break;						case dExportFile:				StandardPutFile(kPrompt, kDefaultFileName, &fileReply);								if(fileReply.sfGood)				{					spec=fileReply.sfFile;										GetDialogItem(dialog, dExportFile, &itemType, &itemHandle, &itemRect);					SetIText(itemHandle, spec.name);					DisposeHandle(itemHandle);										gotFile=true;				}			break;						case dIncludeName:				GetDialogItem(dialog, dIncludeName, &itemType, &itemHandle, &itemRect);				tempBool=GetControlValue((ControlHandle)itemHandle);            	SetControlValue((ControlHandle)itemHandle, !tempBool);            	DisposeHandle(itemHandle);            break;						case dExport:				if(fileReply.sfReplacing)				{					err=FSpDelete(&spec);					if(err!=noErr)						DoError("\pProblem deleting old file!", (long)err, 1872);				}								err=FSpCreate(&spec, kTeachTextCreator, kTextType, smSystemScript);				if(err!=noErr)					DoError("\pProblem creating file!", (long)err, 7612);									GetDialogItem(dialog, dDelimeter, &itemType, &itemHandle, &itemRect);				temp=GetControlValue((ControlHandle)itemHandle);				DisposeHandle(itemHandle);								switch(temp)				{					case pReturn:						delim=13;					break;										case pTab:						delim=9;					break;										case pSpace:						delim=32;					break;				}								GetDialogItem(dialog, dIncludeName, &itemType, &itemHandle, &itemRect);				includeName=GetControlValue((ControlHandle)itemHandle);				DisposeHandle(itemHandle);								err=FSpOpenDF(&spec, fsCurPerm, &refNum);				if(err!=noErr)					DoError("\pProblem opening file!", (long)err, 16732);						err=SetFPos(refNum, fsFromStart, 0L);				if(err!=noErr)					DoError("\pProblem setting file position!", (long)err, 16733);						CopyPString(kExportMessage, message);				length=message[0];				err=FSWrite(refNum, &length, &(message[1]));				if(err!=noErr)					DoError("\pProblem writing to file!", (long)err, 2504);									count+=message[0];								DoWriteExport(spec, folderReply.sfVRefNum, folderReply.sfDirID, delim, includeName, count, refNum, true);								done=true;			break;		}				if((flag)&&(gotFolder)&&(gotFile))		{			flag=false;			HiliteControl((ControlHandle)exportHandle, kEnableButton);			SetDialogDefaultItem(dialog, dExport);		}	}		DisposeDialog(dialog);		if(itemHandle!=nil)		DisposeHandle(itemHandle);	if(exportHandle!=nil)		DisposeHandle(exportHandle);}/* Writes the URLs into a file with kExportMessgae at the beginning of it */void DoWriteExport(FSSpec spec, short vRefNum, long dirID, char delim, Boolean includeName, long count, short refNum, Boolean isFirst){	OSErr	err;	FSSpec	specs[kMaxNumFSSpecs];	Ptr		text;	Str63	name;	short 	itemCount, i, itemIndex=1;	long	length;			do	{    	err=GetDirItems(vRefNum, dirID, NULL, true, true, specs, kMaxNumFSSpecs, &itemCount, &itemIndex);		for(i=0; i<itemCount; ++i)		{			if(IsFolder(specs[i]))				DoWriteExport(spec, vRefNum, specs[i].parID, delim, includeName, count, refNum, false);			else			{				if(includeName)				{					CopyPString(specs[i].name, name);					length=name[0];					FSWrite(refNum, &length, &(name[1]));					count+=name[0];					CopyPString("\p: ", name);					length=name[0];					FSWrite(refNum, &length, &(name[1]));					count+=name[0];				}								text=GetURLAsPtr(specs[i]);				length=GetPtrSize(text);				err=FSWrite(refNum, &length, text);				if(err!=noErr)					DoError("\pProblem writing to file!", (long)err, 16734);				count+=length+1;				length=1;				DisposePtr(text);				err=FSWrite(refNum, &length, &delim);				if(err!=noErr)					DoError("\pProblem writing to file!", (long)err, 2634);			}		}	}	while(err==noErr);			if(isFirst)	{		err=SetEOF(refNum, count-1);		if(err!=noErr)			DoError("\pProblem setting file size!", (long)err, 16735);				err=FSClose(refNum);		if(err!=noErr)			DoError("\pProblem closing file!", (long)err, 16736);				err=FlushVol(kEmptyString, spec.vRefNum);		if(err!=noErr)			DoError("\pProblem flushing volume!", (long)err, 16737);	}}/* Edits a saved URL file */void DoEditURL(void){	StandardFileReply	theReply;	FSSpec				theSpec;	Str255				theURL;	OSErr				err;	Handle				editTextHandle, theURLHandle;	Rect				rect;	Boolean				done=false;	short				type, itemHit;		ChooseFile(&theReply);	if(theReply.sfGood)	{		theSpec=theReply.sfFile;		GetURLAsStr255(theSpec, &theURL);				gDialogPresent=true;		gDialog=GetNewDialog(kEditURLDialogID, nil, kMoveToFront);		if(gDialog==nil)			DoError("\pWhat's wrong with the dialog resource?", 0L, 4333);				GetDialogItem(gDialog, dURL, &type, &editTextHandle, &rect);		SetDialogItemText(editTextHandle, theURL);		SetDialogDefaultItem(gDialog, dLaunch);		SetDialogCancelItem(gDialog, dDone);		SetDialogTracksCursor(gDialog, true);		SelectDialogItemText(gDialog, dURL, 0L, 32767L);				while(!done)		{			ModalDialog(nil, &itemHit);						switch(itemHit)			{				case dOK:					GetDialogItemText(editTextHandle, theURL);									err=FSpDelete(&theSpec);					if(err!=noErr)						DoError("\pProblem deleting old URL file!", (long)err, 7621);										theURLHandle=NewHandleClear(theURL[0]);					BlockMoveData(&(theURL[1]), *theURLHandle, theURL[0]);					PutURL(theSpec, theURLHandle);					DisposeHandle(theURLHandle);										done=true;				break;								case dCancel:					done=true;				break;			}		}				gDialogPresent=false;		DisposeHandle(editTextHandle);		DisposeDialog(gDialog);	}}/* Convert raw text in a Ptr to a Str255 */void PtrToStr255(long length, Ptr thePtr, Str255 theString){	short	l;	if(length>255)		DoError("\pThe string is too long!", nil, 9824);		l=length;		theString[0]=l;	BlockMoveData(thePtr, &(theString[1]), length);}/* Changes the contents of a Str255 to a Ptr */Ptr Str255ToPtr(Str255 theString){	Ptr	thePtr;		thePtr=NewPtrClear(theString[0]);	BlockMoveData(&(theString[1]), thePtr, theString[0]);		return thePtr;}/* Allows the user to search for a URL in a folder o' bookmarks */void DoFind(void){	StandardFolderReply	reply;	Str255				theURL;	StringHandle		theString;	Boolean 			done=false, flag=false;	Handle				editTextHandle, itemHandle;	Rect				editRect, itemRect;	OSErr				err;	short				theFlags, itemHit, editType, itemType, resErr, urlType;		theFlags=kSGFDefaultFlags+kSGFHideNewFolderButton;	err=StandardGetFolder("\pChoose a folder to search in:", &reply, theFlags, NULL);		if(err!=noErr)		DoError("\pProblem with StandardGetFolder!", (long)err, 1719);			if(reply.sfGood)	{		theString=GetString(kStringID+1);		if((resErr=ResError())!=noErr)			DoError("\pProblem reading string!", (long)resErr, 7829);			gDialogPresent=true;		gDialog=GetNewDialog(kEnterSearchDialogID, nil, kMoveToFront);		if(gDialog==nil)			DoError("\pWhat's wrong with the dialog resource?", 0L, 4329);			GetDialogItem(gDialog, dSearchText, &editType, &editTextHandle, &editRect);		HLock((Handle)theString);		SetDialogItemText(editTextHandle, *theString);		HUnlock((Handle)theString);		ReleaseResource((Handle)theString);		SetDialogDefaultItem(gDialog, dSearch);		SetDialogCancelItem(gDialog, dCancel);		SetDialogTracksCursor(gDialog, true);		SelectDialogItemText(gDialog, dSearchText, 0L, 32767L);			ShowWindow(gDialog);		SetPort(gDialog);			while(!done)		{			ModalDialog(nil, &itemHit);					switch(itemHit)			{				case dCancel:					done=true;				break;							case dOK:					done=true;					flag=true;										gDialogPresent=false;									GetDialogItemText(editTextHandle, theURL);					GetDialogItem(gDialog, dURLType, &itemType, &itemHandle, &itemRect);					urlType=GetControlValue((ControlHandle)itemHandle);					DisposeHandle(editTextHandle);					DisposeDialog(gDialog);										SearchInFolder(reply.sfVRefNum, reply.sfDirID, theURL, urlType);					DisposeHandle(itemHandle);				break;							}		}			if(!flag)		{			gDialogPresent=false;			DisposeHandle(editTextHandle);			DisposeDialog(gDialog);		}	}}/* Loops through all the files searching for theString */void SearchInFolder(short refNum, long dirID, Str255 theString, short urlType){	Ptr			theText;	Str255		curURL, curFileName;	DialogPtr	dialog;	Handle		fileNameHandle, urlHandle, findHandle, launchHandle;	Rect		itemRect, findRect, launchRect;	Boolean		done=false, noMore;	short		itemHit, itemType;	long		start=0L, length;	ICError		icErr;		gStart=nil;	MoreSearching(refNum, dirID, theString, urlType);	noMore=GetCurItem(&curURL, &curFileName);		dialog=GetNewDialog(kSearchDialogID, nil, kMoveToFront);		GetDialogItem(dialog, dNameOfFile, &itemType, &fileNameHandle, &itemRect);	GetDialogItem(dialog, dURLFound, &itemType, &urlHandle, &itemRect);	GetDialogItem(dialog, dLaunchURL, &itemType, &launchHandle, &launchRect);	GetDialogItem(dialog, dFindNext, &itemType, &findHandle, &findRect);		SetDialogItemText(fileNameHandle, kMoreDefaultText);	SetDialogItemText(urlHandle, kMoreDefaultText);		if(!noMore)	{		SetDialogItemText(fileNameHandle, curFileName);		SetDialogItemText(urlHandle, curURL);		SetDialogDefaultItem(dialog, dFindNext);	}	else	{		SysBeep(0);		HiliteControl((ControlHandle)launchHandle, kDisableButton);		HiliteControl((ControlHandle)findHandle, kDisableButton);	}		SetDialogCancelItem(dialog, dDone);		ShowWindow(dialog);	SetPort(dialog);		while(!done)	{		ModalDialog(nil, &itemHit);				switch(itemHit)		{			case dDone:				done=true;				GetRidOfList();			break;						case dLaunchURL:				done=true;				GetRidOfList();								length=curURL[0];				theText=Str255ToPtr(curURL);				icErr=ICLaunchURL(gInst, "\p", theText, length, &start, &length);								if(icErr!=noErr)					DoError("\pProblem launching URL! Check to make sure the URL is valid and that Internet Config is set up correctly.", (long)icErr, 9834);			break;						case dFindNext:				noMore=GetCurItem(&curURL, &curFileName);								if(!noMore)				{					SetDialogItemText(fileNameHandle, curFileName);					SetDialogItemText(urlHandle, curURL);				}				else				{					SysBeep(0);					HiliteControl((ControlHandle)findHandle, kDisableButton);				}			break;		}	}		DisposeDialog(dialog);	DisposeHandle(fileNameHandle);	DisposeHandle(urlHandle);	DisposeHandle(findHandle);	DisposeHandle(launchHandle);}/* Disposes of the remaining items in the list of found files */void GetRidOfList(void){	Str255	junk, moreJunk;		while(!GetCurItem(&junk, &moreJunk))		;}/* Performs GetDirItems recursively if needed */void MoreSearching(short refNum, long dirID, Str255 theString, short urlType){	FSSpec		spec[kMaxNumFSSpecs];	OSErr		err;	Str255		theURL;	short		itemCount, i, itemIndex=1, theType;	do	{    	err=GetDirItems(refNum, dirID, NULL, true, true, spec, kMaxNumFSSpecs, &itemCount, &itemIndex);		for (i=0; i<itemCount; ++i)		{			theType=GetURLType(spec[i]);			if((urlType==pAny)||(theType==pNone)||(urlType==theType))			{				SearchInFile(spec[i], theString, &theURL, urlType);				if(IdenticalString(theURL, kJunkText, nil))					AddToMyList(spec[i], theURL);			}		}	}	while (err==noErr);}/* Adds entries to a linked list */void AddToMyList(FSSpec theSpec, Str255 theURL){	ListType	*temp;		temp=(ListType *)NewPtrClear(sizeof(ListType));	if(temp==nil)		DoError("\pNot enough memory!", 0L, 9316);			temp->theSpec=theSpec;	CopyPString(theURL, temp->theURL);	temp->next=gStart;	gStart=temp;}/* Gets the current item */Boolean GetCurItem(Str255 *url, Str255 *fileName){	ListType	*temp;		if(gStart==nil)		return true;	else	{		CopyPString(gStart->theURL, *url);		CopyPString(gStart->theSpec.name, *fileName);		temp=gStart->next;		DisposePtr((Ptr)gStart);		gStart=temp;				return false;	}}/* SearchInFile is pretty damn self explanitory, no? */void SearchInFile(FSSpec theSpec, Str255 theString, Str255 *returnString, short urlType){	FInfo	theInfo;	OSErr	err;	Str255	theURL;	Boolean isDirect;	long	newDirID;		err=FSpGetFInfo(&theSpec, &theInfo);	if(err==fnfErr&&IsFolder(theSpec))	{		FSpGetDirectoryID(&theSpec, &newDirID, &isDirect);		MoreSearching(theSpec.vRefNum, newDirID, theString, urlType);		CopyPString(kJunkText, *returnString);		return;	}	else		if(err!=noErr)			DoError("\pProblem getting info for a file!", (long)err, 14532);				switch(theInfo.fdType)	{		case kTextType:		case kURLType:		case kClipType:		case kNewClipType:			GetURLAsStr255(theSpec, &theURL);		break;					default:			DoError("\pFile not of the right type!", nil, 14533);		break;	}		if(StringInString(1, theURL, theString))		CopyPString(theURL, *returnString);	else		CopyPString(kJunkText, *returnString);}/* Returns true if search is contained somewhere in source */Boolean StringInString(short pos, Str255 source, Str255 search){	Str255	tempStr;	short	i, j, found=1;		if(search[0]>source[0])		return false;		for(i=pos; ((i<=(source[0]-search[0]))&&(found!=0)); i++)	{		tempStr[0]=search[0];		for(j=0; j<=search[0]; j++)			tempStr[j+1]=source[i+j];		found=IdenticalString(tempStr, search, nil);	}		return(found==0);}/* Allows the user to use an Internet search engine through URL Clerk */void DoSearchOnWeb(void){	Boolean			done=false;	Handle			editTextHandle, popupHandle;	Rect			editRect, popupRect;	DialogPtr		dialog;	Str255			theString;	StringHandle	theDefaultTextHandle;	short			resErr, itemHit, editType, popupType, popupValue;		dialog=GetNewDialog(kSearchOnWebDialogID, nil, kMoveToFront);	if(dialog==nil)		DoError("\pWhat's wrong with the dialog resource?", 0L, 4330);		theDefaultTextHandle=GetString(kStringID+2);	if((resErr=ResError())!=noErr)		DoError("\pProblem reading string!", (long)resErr, 4829);			HLock((Handle)theDefaultTextHandle);	SetDialogItemText(editTextHandle, *theDefaultTextHandle);	HUnlock((Handle)theDefaultTextHandle);	ReleaseResource((Handle)theDefaultTextHandle);			SetDialogDefaultItem(dialog, dSearch);	SetDialogCancelItem(dialog, dCancel);	SetDialogTracksCursor(dialog, true);	SelectDialogItemText(dialog, dSearchText, 0L, 32767L);	GetDialogItem(dialog, dSearchText, &editType, &editTextHandle, &editRect);		SetPort(dialog);	ShowWindow(dialog);		while(!done)	{		ModalDialog(nil, &itemHit);				switch(itemHit)		{			case dCancel:				done=true;								DisposeDialog(dialog);			break;						case dSearch:				done=true;							GetDialogItemText(editTextHandle, theString);				GetDialogItem(dialog, dPopupType, &popupType, &popupHandle, &popupRect);				popupValue=GetControlValue((ControlHandle)popupHandle);								DisposeDialog(dialog);								DoSearchURLSynth(popupValue, theString);								DisposeHandle(popupHandle);			break;		}	}		DisposeHandle(editTextHandle);}/* Creates the proper URL to send to the search engine */void DoSearchURLSynth(short engine, Str255 theString){	StringHandle	theBaseHandle;	Handle			theStringHandle;	Str15			key=kKey;	Str255			t;	ICError			icErr;	short			i, theErr;	long			start=0, length;		for(i=1; i<=theString[0]; i++)		if(theString[i]==' ')			theString[i]='+';		switch(engine)	{		case pYahoo:			theBaseHandle=NewString(kYahooSearch);		break;				case pLycos:			theBaseHandle=NewString(kLycosSearch);		break;				case pInfoSeek:			theBaseHandle=NewString(kInfoSeekSearch);		break;				case pExcite:			theBaseHandle=NewString(kExciteSearch);		break;	}		theStringHandle=NewHandle(theString[0]);	BlockMoveData(&(theString[1]), *theStringHandle, theString[0]);		theErr=ReplaceText((Handle)theBaseHandle, theStringHandle, key);	if(theErr<0)		DoError("\pCouldn't replace string!", theErr, 7754);		length=GetHandleSize((Handle)theBaseHandle)-1;		PtrToStr255(length, (void *)&(theBaseHandle[0][1]), t);		icErr=ICLaunchURL(gInst, kEmptyString, (void *)&(t[1]), length, &start, &length);		if(icErr!=noErr)		DoError("\pProblem launching URL! Check to make sure the URL is valid and that Internet Config is set up correctly.", (long)icErr, 6781);		DisposeHandle((Handle)theBaseHandle);	DisposeHandle(theStringHandle);}/* Gets scheduling information from the user */void DoSchedule(void){	DialogPtr			dialog;	Boolean 			done=false, flag=false;	Handle				itemHandle;	Rect				itemRect;	FSSpec				spec;	StandardFileReply	reply;	Str63				fileName;	short				itemHit, itemType, vRefNum;	long				parID;		CopyPString(gPreferences.name, fileName);	dialog=GetNewDialog(kScheduleDialogID, nil, kMoveToFront);	if(dialog==nil)		DoError("\pWhat's wrong with the dialog resource?", 0L, 4444);		if(fileName[0]!=0)	{		GetDialogItem(dialog, dFileName, &itemType, &itemHandle, &itemRect);		SetIText(itemHandle, fileName);	}		vRefNum=gPreferences.vRefNum;	parID=gPreferences.dirID;		SetDialogDefaultItem(dialog, dOK);	SetDialogCancelItem(dialog, dCancel);		GetDialogItem(dialog, dHour, &itemType, &itemHandle, &itemRect);	SetControlValue((ControlHandle)itemHandle, gPreferences.hour);		GetDialogItem(dialog, dMinute, &itemType, &itemHandle, &itemRect);	SetControlValue((ControlHandle)itemHandle, gPreferences.minute);		GetDialogItem(dialog, dAmPm, &itemType, &itemHandle, &itemRect);	SetControlValue((ControlHandle)itemHandle, gPreferences.amPm);		GetDialogItem(dialog, dDay, &itemType, &itemHandle, &itemRect);	SetControlValue((ControlHandle)itemHandle, gPreferences.day);		ShowWindow(dialog);	SetPort(dialog);		while(!done)	{		ModalDialog(nil, &itemHit);					switch(itemHit)		{			case dOK:				if(flag)				{					gPreferences.vRefNum=vRefNum;					gPreferences.dirID=parID;					CopyPString(fileName, gPreferences.name);				}								GetDialogItem(dialog, dHour, &itemType, &itemHandle, &itemRect);				gPreferences.hour=GetControlValue((ControlHandle)itemHandle);								GetDialogItem(dialog, dMinute, &itemType, &itemHandle, &itemRect);				gPreferences.minute=GetControlValue((ControlHandle)itemHandle);								GetDialogItem(dialog, dAmPm, &itemType, &itemHandle, &itemRect);				gPreferences.amPm=GetControlValue((ControlHandle)itemHandle);								GetDialogItem(dialog, dDay, &itemType, &itemHandle, &itemRect);				gPreferences.day=GetControlValue((ControlHandle)itemHandle);								if(fileName[0]!=0)					gFlag=true;				else					gFlag=false;								done=true;			break;						case dCancel:				done=true;			break;						case dChooseFile:				ChooseFile(&reply);								if(reply.sfGood)				{					spec=reply.sfFile;					vRefNum=spec.vRefNum;					parID=spec.parID;										CopyPString(spec.name, fileName);					GetDialogItem(dialog, dFileName, &itemType, &itemHandle, &itemRect);					SetIText(itemHandle, spec.name);										flag=true;				}			break;						case dClear:				fileName[0]=0;								vRefNum=kJunk;				parID=kJunk;				GetDialogItem(dialog, dFileName, &itemType, &itemHandle, &itemRect);				SetDialogItemText(itemHandle, kDefaultText);								flag=true;			break;		}	}		DisposeDialog(dialog);	DisposeHandle(itemHandle);}/* Uses StandardGetFile() to choose a file of the right type */void ChooseFile(StandardFileReply *reply){	SFTypeList	typeList;		typeList[0]=kTextType;	typeList[1]=kClipType;	typeList[2]=kNewClipType;	typeList[3]=kURLType;		StandardGetFile(nil, 4, typeList, reply);}/* Uses StandardGetFile() to choose a file of the right type out of a larger selection of files*/void ChooseFileExtended(StandardFileReply *reply){	SFTypeList	typeList;		typeList[0]=kTextType;	typeList[1]=kClipType;	typeList[2]=kNewClipType;	typeList[3]=kURLType;	typeList[4]=kAnarchieType;	typeList[5]=kAnarchieURLType;		StandardGetFile(nil, 6, typeList, reply);}/* Changes the first '-' in a string to a ':' */void ChangeToColon(Str255 theString){	short	i;		for(i=1; i<=theString[0]; i++)		if(theString[i]==':')			return;		else			if(theString[i]=='-')			{				theString[i]=':';				return;			}}/* Changes ':' to '-' */void ChangeFromColon(Str255 theString){	short	i;		for(i=1; i<=theString[0]; i++)		if(theString[i]==':')		{			theString[i]='-';			return;		}}/* Copies one pascal string to another */void CopyPString(Str255 source, Str255 dest){    BlockMoveData(source, dest, source[0]+1L);}/* Copies contents of one Ptr to another */void CopyPtr(Ptr source, Ptr dest){	BlockMoveData(source, dest, GetPtrSize(dest));}/* Writes global preferences to prefs file */void DoQuit(void){	Handle	tempHandle, oldPrefs;	OSErr	err;	short	resErr;		UseResFile(gPrefsResNum);		err=PtrToHand(&gPreferences, &tempHandle, sizeof(Preferences));	if(err!=noErr)		DoError("\pMemory related error!", (long)err, 211);		oldPrefs=Get1Resource(kPrefsType, kPrefsID);	if((resErr=ResError())!=noErr)		DoError("\pProblem reading resources!", (long)resErr, 212);			RemoveResource(oldPrefs);	if((resErr=ResError())!=noErr)		DoError("\pProblem removing resources!", (long)resErr, 213);			AddResource(tempHandle, kPrefsType, kPrefsID, kEmptyString);	if((resErr=ResError())!=noErr)		DoError("\pProblem adding resources!", (long)resErr, 214);			WriteResource(tempHandle);	if((resErr=ResError())!=noErr)		DoError("\pProblem writing resources!", (long)resErr, 241);			CloseResFile(gPrefsResNum);	if((resErr=ResError())!=noErr)		DoError("\pProblem closing resource fork!", (long)resErr, 205);			UseResFile(gAppResNum);		Quit(false);}