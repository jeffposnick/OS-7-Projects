/* #Includes */#ifndef	__ICONS__	#include <Icons.h>#endif#ifndef __QDOFFSCREEN__	#include <QDOffscreen.h>#endif/* Structs */struct MapInfo{	short	width;	short	height;};typedef struct MapInfo MapInfo;struct MapElement{	short	id;};typedef struct MapElement MapElement;/* #Defines */#define	kMoveToFront	(WindowPtr)-1L#define kIconSize		32#define kPlayerIndex	0#define kMinValue		0#define kMapInfoType	'MapS'#define kMapType		'mAp@'#define kIconType		'cicn'#define kMapSizeID		128#define kEmptyString	"\p"#define kLeft			32#define kTop			32/* Globals */CIconHandle		*icons;MapElement		**map;Rect			gRect;WindowPtr		gWindow;CGrafPtr		gPort;GDHandle		gGDHandle;GWorldPtr		gBackgroundWorld, gScreenBufferWorld;MapInfo			theInfo;short			numIcons, curX=1, curY=1, oldX, oldY;/* Function Prototypes */void main(void);void GraphInit(void);void PrepareToDraw(GWorldPtr theWorld);void FinishDraw(GWorldPtr theWorld);void DrawScreen(void);void MoveGuy(void);void WindowInit(void);void ToolboxInit(void);void ToolboxInit(void){	InitGraf(&qd.thePort);	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs(0L);	FlushEvents(everyEvent, 0);	InitCursor();	MaxApplZone();	MoreMasters();}void GraphInit(void){	QDErr				qdErr;	Rect				gRect;	SFTypeList			types;	OSErr				err;	StandardFileReply	reply;	FSSpec				spec;	Rect				rect;	Handle				mapHandle;	short				resNum, resErr, i, j;	MapElement			k;		types[0]=kMapType;	StandardGetFile(nil, 1, types, &reply);		if(reply.sfGood)	{		spec=reply.sfFile;				resNum=FSpOpenResFile(&spec, fsRdPerm);		if((resErr=ResError())!=noErr) DebugStr("\pCan't open map!");				mapHandle=Get1IndResource(kMapType, 1);		if(((resErr=ResError())!=noErr)||(mapHandle==nil)) DebugStr("\pCan't read resource!");				theInfo=**(MapInfo**)Get1Resource(kMapInfoType, kMapSizeID);				numIcons=Count1Resources(kIconType);				if((theInfo.width*theInfo.height*sizeof(MapElement))!=GetHandleSize(mapHandle)) DebugStr("\pMap data is incorrect!");				map=(MapElement **)NewPtr(theInfo.width*sizeof(MapElement *));		if(map==nil) DebugStr("\pNewPtr failed!");		for(i=0; i<theInfo.width; i++)		{			map[i]=(MapElement *)NewPtr(theInfo.height*sizeof(MapElement));			if(map[i]==nil) DebugStr("\pNewPtr failed!");		}		for(i=0; i<theInfo.width; i++)			BlockMoveData(((*mapHandle)+(i*sizeof(MapElement))), map[i], (theInfo.height*sizeof(MapElement)));				ReleaseResource(mapHandle);				gRect.left=kMinValue;		gRect.top=kMinValue;		gRect.right=theInfo.width*kIconSize;		gRect.bottom=theInfo.height*kIconSize;				qdErr=NewGWorld(&gBackgroundWorld, 0, &gRect, nil, nil, nil);		if(qdErr!=noErr) DebugStr("\pProblem allocating GWorld");		qdErr=NewGWorld(&gScreenBufferWorld, 0, &gRect, nil, nil, nil);		if(qdErr!=noErr) DebugStr("\pProblem allocating GWorld");			PrepareToDraw(gBackgroundWorld);				icons=(CIconHandle *)NewPtrClear(numIcons*sizeof(CIconHandle));		if(icons==nil) DebugStr("\pNewPtr failed!");				for(i=0; i<numIcons; i++)			icons[i]=GetCIcon(i);		for(i=0; i<theInfo.width; i++)		{			for(j=0; j<theInfo.height; j++)			{				rect.top=i*kIconSize;				rect.bottom=(i+1)*kIconSize;				rect.left=j*kIconSize;				rect.right=(j+1)*kIconSize;				k=map[i][j];				PlotCIcon(&rect, icons[k.id]);			}		}		FinishDraw(gBackgroundWorld);	}}void PrepareToDraw(GWorldPtr theWorld){	GetGWorld(&gPort, &gGDHandle);	SetGWorld(theWorld, nil);	if(!(LockPixels(GetGWorldPixMap(theWorld))))		DebugStr("\pGWorld was purged");}void FinishDraw(GWorldPtr theWorld){	UnlockPixels(GetGWorldPixMap(theWorld));	SetGWorld(gPort, gGDHandle);}void DrawScreen(void){	Rect	rect;	int		k;		PrepareToDraw(gScreenBufferWorld);	CopyBits((BitMap *)(*(GetGWorldPixMap(gBackgroundWorld))), (BitMap *)(*(GetGWorldPixMap(gScreenBufferWorld))), &(gWindow->portRect), &(gWindow->portRect), srcCopy, nil);	rect.top=curY*kIconSize;	rect.bottom=(curY+1)*kIconSize;	rect.left=curX*kIconSize;	rect.right=(curX+1)*kIconSize;	PlotCIcon(&rect, icons[kPlayerIndex]);		FinishDraw(gScreenBufferWorld);		SetGWorld((CGrafPtr)gWindow, GetMainDevice());	CopyBits((BitMap *)(*(GetGWorldPixMap(gScreenBufferWorld))), (&(gWindow->portBits)), &(gWindow->portRect), &(gWindow->portRect), srcCopy, nil);}void	WindowInit(void){	Rect	bounds;	int		w, h;		if(theInfo.width>14)		w=14;	else		w=theInfo.width;			if(theInfo.height>14)		h=14;	else		h=theInfo.height;		SetRect(&bounds, kLeft, kTop, w*kIconSize+kLeft, h*kIconSize+kTop);	gWindow=NewCWindow(nil, &bounds, kEmptyString, TRUE, altDBoxProc, kMoveToFront, false, nil);	SetGWorld((CGrafPtr)gWindow, GetMainDevice());}void main(void){	EventRecord event;	char 		theChar;		ToolboxInit();	GraphInit();	WindowInit();	DrawScreen();		while(!Button())	{		WaitNextEvent(everyEvent, &event, 10, nil);				switch(event.what)		{			case keyDown:			case autoKey:				theChar=(event.message & charCodeMask);								oldY=curY;				oldX=curX;								switch(theChar)				{					case '2':						if(++curY>(theInfo.height-1))							--curY;					break;										case '8':						if(--curY==-1)							++curY;					break;										case '6':						if(++curX>(theInfo.width-1))							--curX;					break;										case '4':						if(--curX==-1)							++curX;					break;										case '7':						if(--curY==-1)							++curY;						if(--curX==-1)							++curX;					break;										case '9':						if(--curY==-1)							++curY;						if(++curX>(theInfo.width-1))							--curX;					break;										case '3':						if(++curY>(theInfo.height-1))							--curY;						if(++curX>(theInfo.width-1))							--curX;					break;										case '1':						if(++curY>(theInfo.height-1))							--curY;						if(--curX==-1)							++curX;					break;				}								DrawScreen();							break;		}	}		DisposeGWorld(gScreenBufferWorld);	DisposeGWorld(gBackgroundWorld);}